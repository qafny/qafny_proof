Fixpoint translate (e : pexp) : cmd :=
  match e with
  | PSKIP => Skip
  | Let x a e' =>
      match a with
      | AE ae => Assign (Scalar x) (translate_aexp ae)
      | Meas y => ArrayWrite y (Const 0) (VarExpr (Scalar x))
      end
  | AppU l e' => Assign (Array l 0) (translate_exp e')
  | AppSU _ => Skip  (* Simplified, as we don't have direct cmd equivalent *)
  | If b e' => If (translate_bexp b) (translate e') Skip
  | For x l h b p => 
      While (translate_bexp b) 
            (Seq (translate p) 
                 (Assign (Scalar x) (Plus (VarExpr (Scalar x)) (Const 1))))
  | PSeq e1 e2 => Seq (translate e1) (translate e2)
  end.

Fixpoint translate_aexp (a : aexp) : expr :=
  match a with
  | ANum n => Const n
  | AId x => VarExpr (Scalar x)
  | APlus a1 a2 => Plus (translate_aexp a1) (translate_aexp a2)
  | AMinus a1 a2 => Minus (translate_aexp a1) (translate_aexp a2)
  end.

Fixpoint translate_bexp (b : bexp) : expr :=
  match b with
  | BTrue => Const 1
  | BFalse => Const 0
  | BEq a1 a2 => Minus (translate_aexp a1) (translate_aexp a2)
  | BLt a1 a2 => Minus (translate_aexp a2) (translate_aexp a1)
  | BNeg b' => Minus (Const 1) (translate_bexp b')
  end.

Fixpoint translate_exp (e : exp) : expr :=
  match e with
  | EX => VarExpr (Scalar "X")  (* Assuming X is a predefined variable *)
  | EY => VarExpr (Scalar "Y")  (* Assuming Y is a predefined variable *)
  | EZ => VarExpr (Scalar "Z")  (* Assuming Z is a predefined variable *)
  | EH => VarExpr (Scalar "H")  (* Assuming H is a predefined variable *)
  | CNOT => VarExpr (Scalar "CNOT")  (* Assuming CNOT is a predefined variable *)
  end.




Inductive pexp := PSKIP 
            | Let (x:var) (n:maexp) (e:pexp)
            | AppSU (e:single_u)
            | AppU (l:locus) (e:exp) 
            | PSeq (s1:pexp) (s2:pexp)
          (*compile to CU / CNOT *)
            | If (x:bexp) (s1:pexp)
            | For (x:var) (l:aexp) (h:aexp) (b:bexp) (p:pexp)
            | Diffuse (x:varia) 







(* Function to translate pexp to cmd *)
Fixpoint translate (e: pexp) : cmd :=
  match e with
  | PSKIP => Skip 
  | Let x n e' => Assign x (translate_maexp n) translate e'
  | AppSU a => Skip (* Placeholder for specialized command *)
  | AppU l e' => Skip (* Placeholder for specialized command *)
  | PSeq e1 e2 => Seq (translate e1) (translate e2)
  | If x e' => If (translate_bexp x) (translate e')
  | For x l h b p =>
      (* Implementation of For loop *)
      let loop_body := translate p in
      let initialization := Assign x (translate_aexp l) in
      (* Assuming a Dummy variable `counter` for loop operations *)
      Seq initialization (While (translate_bexp b) (Seq loop_body (Assign x (translate_aexp (add l (const 1))))))
  | Diffuse x => Skip (* Placeholder for specialized command *)
  end.

Inductive translate_pexp_rel : pexp -> cmd -> Prop :=

  | TransSkip : 
      translate_pexp_rel PSKIP Skip

  | TransLet : forall (x : BasicUtility.var) (e : aexp) (s : pexp) (c : cmd),
      translate_pexp_rel s c ->
      translate_pexp_rel (Let x (AE e) s) (Seq (Assign (var_equiv x) (aexp_to_expr e)) c)

  | TransAppU : forall l e c,
      translate_pexp_rel e c ->
      translate_pexp_rel (AppU l (pexp_to_exp e)) c

  | TransIf : forall (b : pexp) (s1 s2 : cmd) (c1 c2 : cmd),
      translate_pexp_rel s1 c1 ->
      translate_pexp_rel s2 c2 ->
      translate_pexp_rel (If (pexp_to_expr b)s1 s2) (If (pexp_to_expr b) c1 c2)

  | TransSeq : forall s1 s2 c1 c2,
      translate_pexp_rel s1 c1 ->
      translate_pexp_rel s2 c2 ->
      translate_pexp_rel (PSeq s1 s2) (Seq c1 c2)

  | TransWhile : forall b s c,
      translate_pexp_rel s c ->
      translate_pexp_rel (While b s) (While b c)

  | TransDiffuse : forall (x : BasicUtility.var),
      translate_pexp_rel (Diffuse x) (Assign (var_equiv x) (Const 0)).












